pizzaDesign
# week 6 code
# pizza dough - three main ingredients - flour, salt, baking powder
pizzaDesign <- expand.grid(flour = gl(2, 1, labels = c("-", "+")),
salt = gl(2, 1, labels = c("-", "+")),
bakPow = gl(2, 1, labels = c("-", "+")),
score = NA)
pizzaDesign[order(pizzaDesign$ord),]
##Ho: are means are equal
##Ha: at least onw mean differs from the others
## Pvalue < alpha (0.05) then reject Ho
confint(model.power)
model.power = lm(power~type,data=data)
##Ho: are means are equal
##Ha: at least onw mean differs from the others
## Pvalue < alpha (0.05) then reject Ho
confint(model.power)
model.power=lm(power~type,data=data)
Ho: are means are equal
##Ho: are means are equal
##Ha: at least onw mean differs from the others
## Pvalue < alpha (0.05) then reject Ho
##confint(model.power)
##Ho: are means are equal
##Ha: at least onw mean differs from the others
## Pvalue < alpha (0.05) then reject Ho
confint(model.power)
library(SixSigma)
library(SixSigma)
if(!require(installr)) {
install.packages("installr");
require(installr)
} #load / install+load installr
updateR()
library(SixSigma)
library(SixSigma)
library(SixSigma)
library(SixSigma)
# installing/loading the package:
if(!require(installr)) {
install.packages("installr");
require(installr)
} #load / install+load installr
##Ho: are means are equal
##Ha: at least onw mean differs from the others
## Pvalue < alpha (0.05) then reject Ho
confint(model.power)
library(SixSigma)
##Ho: are means are equal
##Ha: at least onw mean differs from the others
## Pvalue < alpha (0.05) then reject Ho
confint(model.power)
install.packages("vctrs")
library(SixSigma)
##Ho: are means are equal
##Ha: at least onw mean differs from the others
## Pvalue < alpha (0.05) then reject Ho
confint(model.power)
data=ss.data.strings
boxplot(power~type,data=data)
model.power=lm(power~type,data=data)
summary(model.power)
str(data)
##Ho: are means are equal
##Ha: at least onw mean differs from the others
## Pvalue < alpha (0.05) then reject Ho
##Ho: are means are equal
##Ha: at least onw mean differs from the others
## Pvalue < alpha (0.05) then reject Ho
confint(model.power)
# optional hw 1 1.2
geico <- c(4.7, 8.3, 9.2)
progressive <- c(7.4, 6.7, 8.9)
# optional hw 1 1.2
geico <- c(4.7, 8.3, 9.2)
progressive <- c(7.4, 6.7, 8.9)
usaa <- c(3.8, 6.3, 8.1)
# Calculate the mean value for each group
mean_geico <- mean(geico)
mean_progressive <- mean(progressive)
mean_usaa <- mean(usaa)
# Compare means to find the best group
best_group <- which.max(c(mean_geico, mean_progressive, mean_usaa))
cat("Mean values - USAA:", mean_usaa, "\n")
cat("Group with the highest mean value: ", c("Geico", "Progressive", "USAA")[best_group])
cat("Mean values - Progressive:", mean_progressive, "\n")
source("C:/Users/brtas/Documents/optional hw 1 1.2.R", echo=TRUE)
data <- data.frame(
Group = rep(c("Geico", "Progressive", "USAA"), each = 3),
Value = c(4.7, 8.3, 9.2, 7.4, 6.7, 8.9, 3.8, 6.3, 8.1)
)
View(data)
ggplot(data, aes(x = Group, y = Value, fill = Group)) +
geom_boxplot() +
labs(title = "Box Plot Comparison of Values", x = "Group", y = "Value") +
scale_fill_discrete(name = "Group")
source("C:/Users/brtas/Documents/optional hw 1 1.2.R", echo=TRUE)
source("C:/Users/brtas/Documents/optional hw 1 1.2.R", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
View(actor_scores)
View(actor_ratings)
library(stats)
setwd("C:/Users/brtas/Documents/GitHub/Housing-ML-Project")
# submission 14, 0.13712
# rank is based on RMSE
# trying to normalize the highest correlated values
# load libraries
library(caTools)
library(randomForest)
library(dplyr)
library(ggplot2)
#install.packages("PerformanceAnalytics")
library(PerformanceAnalytics)
library(stats)
# loading data
dataTrain = read.csv("train.csv")
dataTest = read.csv("test.csv")
# remove unnecessary columns
dataTrain$Id = NULL
dataTest$Id = NULL
dataTrain$PoolQC = NULL
dataTest$PoolQC = NULL
dataTrain$MiscFeature = NULL
dataTest$MiscFeature = NULL
dataTrain$Alley = NULL
dataTest$Alley = NULL
dataTrain$Fence = NULL
dataTest$Fence = NULL
dataTrain$MSZoning = NULL
dataTest$MSZoning = NULL
#SalePrice = dataTrain$SalePrice
# log transforming SalePrice since it is not normalized
SalePrice1 <- log(dataTrain$SalePrice)
SalePrice <- log(dataTrain$SalePrice)
dataTrain$SalePrice = SalePrice1
# cleaning Train and test
character_columns = sapply(dataTrain, is.character)
dataTrainChar = dataTrain[, character_columns]
character_columns = sapply(dataTrain, is.character)
dataTestChar = dataTest[, character_columns]
#below works for test
for (col_name in names(dataTrainChar)) {
mean_sale_price = tapply(SalePrice, dataTrainChar[[col_name]], mean)
# Use a different variable name for rank
rank_values = rank(mean_sale_price)
# Rename the values in dataTestChar based on rank
dataTestChar[[col_name]] <- ifelse(!is.na(match(dataTestChar[[col_name]], names(mean_sale_price))),
rank_values[match(dataTestChar[[col_name]], names(mean_sale_price))],
dataTestChar[[col_name]])
dataTestChar[[col_name]] = as.numeric(dataTestChar[[col_name]])
}
# below works for train
for (col_name in names(dataTrainChar)) {
# If the column is a factor, calculate the mean SalePrice for each unique value
mean_sale_price = tapply(SalePrice, dataTrainChar[[col_name]], mean)
#ordered = order(mean_sale_price)
rank = rank(mean_sale_price)
# Add the results to the result data frame
dataTrainChar[[col_name]] <- ifelse(!is.na(match(dataTrainChar[[col_name]], names(rank))),
rank[match(dataTrainChar[[col_name]], names(rank))],
dataTrainChar[[col_name]])
dataTrainChar[[col_name]] = as.numeric(dataTrainChar[[col_name]])
}
# creates dataframe with only numeric/int values for train
missing_columns = setdiff(names(dataTrain), names(dataTrainChar))
dataTrainNum <- dataTrain[, missing_columns]
# removes the sale price column
dataTrainNum$SalePrice = NULL
# below for cleaning test data
# creates dataframe with only numeric/int values
missing_columns = setdiff(names(dataTest), names(dataTestChar))
dataTestNum <- dataTest[, missing_columns]
# combines everything into one dataframe for train data
dataTrainAll = cbind(dataTrainChar, dataTrainNum)
dataTrainAll$SalePrice = dataTrain$SalePrice
# corrects NAs for train data
dataTrainAll[] <- lapply(dataTrainAll, function(x) {
ifelse(is.na(x), mean(x, na.rm = TRUE), x)
})
# combines everything into one dataframe
dataTestAll = cbind(dataTestChar, dataTestNum)
# changes NA to mean
dataTestAll <- dataTestAll %>%
mutate(across(everything(), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))
# mutate some of the data based on histogram shapes
# left/right skewed data
#dataTrainAll$TotalBsmtSF = log(dataTrain$TotalBsmtSF) # causes infinite values
#dataTestAll$TotalBsmtSF = log(dataTest$TotalBsmtSF)
dataTrainAll$X1stFlrSF = log(dataTrain$X1stFlrSF)
dataTestAll$X1stFlrSF = log(dataTest$X1stFlrSF)
dataTrainAll$GrLivArea = log(dataTrain$GrLivArea)
dataTestAll$GrLivArea = log(dataTest$GrLivArea)
# mutate some of the data based on histogram shapes
# left/right skewed data
#dataTrainAll$TotalBsmtSF = log(dataTrain$TotalBsmtSF) # causes infinite values
#dataTestAll$TotalBsmtSF = log(dataTest$TotalBsmtSF)
dataTrainAll$X1stFlrSF = log(dataTrain$X1stFlrSF)
dataTestAll$X1stFlrSF = log(dataTest$X1stFlrSF)
dataTrainAll$GrLivArea = log(dataTrain$GrLivArea)
dataTestAll$GrLivArea = log(dataTest$GrLivArea)
# loading data
dataTrain = read.csv("train.csv")
dataTest = read.csv("test.csv")
# remove unnecessary columns
dataTrain$Id = NULL
dataTest$Id = NULL
dataTrain$PoolQC = NULL
dataTest$PoolQC = NULL
dataTrain$MiscFeature = NULL
dataTest$MiscFeature = NULL
dataTrain$Alley = NULL
dataTest$Alley = NULL
dataTrain$Fence = NULL
dataTest$Fence = NULL
dataTrain$MSZoning = NULL
dataTest$MSZoning = NULL
#SalePrice = dataTrain$SalePrice
# log transforming SalePrice since it is not normalized
SalePrice1 <- log(dataTrain$SalePrice)
SalePrice <- log(dataTrain$SalePrice)
dataTrain$SalePrice = SalePrice1
# cleaning Train and test
character_columns = sapply(dataTrain, is.character)
dataTrainChar = dataTrain[, character_columns]
character_columns = sapply(dataTrain, is.character)
dataTestChar = dataTest[, character_columns]
#below works for test
for (col_name in names(dataTrainChar)) {
mean_sale_price = tapply(SalePrice, dataTrainChar[[col_name]], mean)
# Use a different variable name for rank
rank_values = rank(mean_sale_price)
# Rename the values in dataTestChar based on rank
dataTestChar[[col_name]] <- ifelse(!is.na(match(dataTestChar[[col_name]], names(mean_sale_price))),
rank_values[match(dataTestChar[[col_name]], names(mean_sale_price))],
dataTestChar[[col_name]])
dataTestChar[[col_name]] = as.numeric(dataTestChar[[col_name]])
}
# below works for train
for (col_name in names(dataTrainChar)) {
# If the column is a factor, calculate the mean SalePrice for each unique value
mean_sale_price = tapply(SalePrice, dataTrainChar[[col_name]], mean)
#ordered = order(mean_sale_price)
rank = rank(mean_sale_price)
# Add the results to the result data frame
dataTrainChar[[col_name]] <- ifelse(!is.na(match(dataTrainChar[[col_name]], names(rank))),
rank[match(dataTrainChar[[col_name]], names(rank))],
dataTrainChar[[col_name]])
dataTrainChar[[col_name]] = as.numeric(dataTrainChar[[col_name]])
}
# creates dataframe with only numeric/int values for train
missing_columns = setdiff(names(dataTrain), names(dataTrainChar))
dataTrainNum <- dataTrain[, missing_columns]
# removes the sale price column
dataTrainNum$SalePrice = NULL
# below for cleaning test data
# creates dataframe with only numeric/int values
missing_columns = setdiff(names(dataTest), names(dataTestChar))
dataTestNum <- dataTest[, missing_columns]
# combines everything into one dataframe for train data
dataTrainAll = cbind(dataTrainChar, dataTrainNum)
dataTrainAll$SalePrice = dataTrain$SalePrice
# corrects NAs for train data
dataTrainAll[] <- lapply(dataTrainAll, function(x) {
ifelse(is.na(x), mean(x, na.rm = TRUE), x)
})
# combines everything into one dataframe
dataTestAll = cbind(dataTestChar, dataTestNum)
# changes NA to mean
dataTestAll <- dataTestAll %>%
mutate(across(everything(), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))
# mutate some of the data based on histogram shapes
# left/right skewed data
#dataTrainAll$TotalBsmtSF = log(dataTrain$TotalBsmtSF) # causes infinite values
#dataTestAll$TotalBsmtSF = log(dataTest$TotalBsmtSF)
dataTrainAll$X1stFlrSF = log(dataTrain$X1stFlrSF)
dataTestAll$X1stFlrSF = log(dataTest$X1stFlrSF)
dataTrainAll$GrLivArea = log(dataTrain$GrLivArea)
dataTestAll$GrLivArea = log(dataTest$GrLivArea)
pca_model <- prcomp(dataTrainAll, scale. = TRUE)
# Transform train_data using the PCA model
train_data_pca <- predict(pca_model, dataTrainAll)
# Transform test_data using the same PCA model
test_data_pca <- predict(pca_model, dataTestAll)
# submission 14, 0.13712
# rank is based on RMSE
# trying to normalize the highest correlated values
# load libraries
library(caTools)
library(randomForest)
library(dplyr)
library(ggplot2)
#install.packages("PerformanceAnalytics")
library(PerformanceAnalytics)
library(stats)
# loading data
dataTrain = read.csv("train.csv")
dataTest = read.csv("test.csv")
# remove unnecessary columns
dataTrain$Id = NULL
dataTest$Id = NULL
dataTrain$PoolQC = NULL
dataTest$PoolQC = NULL
dataTrain$MiscFeature = NULL
dataTest$MiscFeature = NULL
dataTrain$Alley = NULL
dataTest$Alley = NULL
dataTrain$Fence = NULL
dataTest$Fence = NULL
dataTrain$MSZoning = NULL
dataTest$MSZoning = NULL
#SalePrice = dataTrain$SalePrice
# log transforming SalePrice since it is not normalized
SalePrice1 <- log(dataTrain$SalePrice)
SalePrice <- log(dataTrain$SalePrice)
dataTrain$SalePrice = SalePrice1
# cleaning Train and test
character_columns = sapply(dataTrain, is.character)
dataTrainChar = dataTrain[, character_columns]
character_columns = sapply(dataTrain, is.character)
dataTestChar = dataTest[, character_columns]
#below works for test
for (col_name in names(dataTrainChar)) {
mean_sale_price = tapply(SalePrice, dataTrainChar[[col_name]], mean)
# Use a different variable name for rank
rank_values = rank(mean_sale_price)
# Rename the values in dataTestChar based on rank
dataTestChar[[col_name]] <- ifelse(!is.na(match(dataTestChar[[col_name]], names(mean_sale_price))),
rank_values[match(dataTestChar[[col_name]], names(mean_sale_price))],
dataTestChar[[col_name]])
dataTestChar[[col_name]] = as.numeric(dataTestChar[[col_name]])
}
# below works for train
for (col_name in names(dataTrainChar)) {
# If the column is a factor, calculate the mean SalePrice for each unique value
mean_sale_price = tapply(SalePrice, dataTrainChar[[col_name]], mean)
#ordered = order(mean_sale_price)
rank = rank(mean_sale_price)
# Add the results to the result data frame
dataTrainChar[[col_name]] <- ifelse(!is.na(match(dataTrainChar[[col_name]], names(rank))),
rank[match(dataTrainChar[[col_name]], names(rank))],
dataTrainChar[[col_name]])
dataTrainChar[[col_name]] = as.numeric(dataTrainChar[[col_name]])
}
# creates dataframe with only numeric/int values for train
missing_columns = setdiff(names(dataTrain), names(dataTrainChar))
dataTrainNum <- dataTrain[, missing_columns]
# removes the sale price column
dataTrainNum$SalePrice = NULL
# below for cleaning test data
# creates dataframe with only numeric/int values
missing_columns = setdiff(names(dataTest), names(dataTestChar))
dataTestNum <- dataTest[, missing_columns]
# combines everything into one dataframe for train data
dataTrainAll = cbind(dataTrainChar, dataTrainNum)
#dataTrainAll$SalePrice = dataTrain$SalePrice
# corrects NAs for train data
dataTrainAll[] <- lapply(dataTrainAll, function(x) {
ifelse(is.na(x), mean(x, na.rm = TRUE), x)
})
# combines everything into one dataframe
dataTestAll = cbind(dataTestChar, dataTestNum)
# changes NA to mean
dataTestAll <- dataTestAll %>%
mutate(across(everything(), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))
# mutate some of the data based on histogram shapes
# left/right skewed data
#dataTrainAll$TotalBsmtSF = log(dataTrain$TotalBsmtSF) # causes infinite values
#dataTestAll$TotalBsmtSF = log(dataTest$TotalBsmtSF)
dataTrainAll$X1stFlrSF = log(dataTrain$X1stFlrSF)
dataTestAll$X1stFlrSF = log(dataTest$X1stFlrSF)
dataTrainAll$GrLivArea = log(dataTrain$GrLivArea)
dataTestAll$GrLivArea = log(dataTest$GrLivArea)
# using PCA methods
pca_model <- prcomp(dataTrainAll, scale. = TRUE)
# Transform train_data using the PCA model
train_data_pca <- predict(pca_model, dataTrainAll)
# Transform test_data using the same PCA model
test_data_pca <- predict(pca_model, dataTestAll)
dataTrainAll$SalePrice = dataTrain$SalePrice
# testing the accuracy (need to use the train data to get the accuracy) ###
startModel = randomForest(SalePrice ~ ., data = train_data_pca, ntree = 500)
# Predict sale prices for the test dataset
#predictions = predict(startModel, newdata = dataTestAll)
predictions1 = predict(startModel, newdata = dataTestAll)
View(train_data_pca)
View(test_data_pca)
# Predict sale prices for the test dataset
#predictions = predict(startModel, newdata = dataTestAll)
predictions1 = predict(startModel, newdata = dataTestAll)
# Predict sale prices for the test dataset
#predictions = predict(startModel, newdata = dataTestAll)
predictions1 = predict(startModel, newdata = test_data_pca)
predictions = exp(predictions1)
IDnum = 1461:2919
MySubmission = data.frame(Id = IDnum, SalePrice = predictions)
write.csv(MySubmission, "predictionsRandomForest.csv", row.names=FALSE)
startModel <- lm(SalePrice ~ ., data = train_data_pca)
dataframe_data <- as.data.frame(train_data_pca)
dataframe_datatrain <- as.data.frame(train_data_pca)
dataframe_datatest <- as.data.frame(test_data_pca)
startModel <- lm(SalePrice ~ ., data = dataframe_datatrain)
# Predict sale prices for the test dataset
#predictions = predict(startModel, newdata = dataTestAll)
predictions1 = predict(startModel, newdata = dataframe_datatest)
predictions = exp(predictions1)
MySubmission = data.frame(Id = IDnum, SalePrice = predictions)
write.csv(MySubmission, "predictionslinearRegression.csv", row.names=FALSE)
# Install and load required packages if not installed
if (!requireNamespace("shiny", quietly = TRUE)) {
install.packages("shiny")
}
if (!requireNamespace("ggplot2", quietly = TRUE)) {
install.packages("ggplot2")
}
# Load libraries
library(shiny)
library(ggplot2)
# Define UI
ui <- fluidPage(
titlePanel("Interactive Plots and Download"),
sidebarLayout(
sidebarPanel(
# Add interactive inputs (e.g., selectInput, sliderInput, radioButtons)
selectInput("variable", "Select variable", choices = colnames(mtcars)),
sliderInput("bins", "Select bins", min = 1, max = 50, value = 30),
# Add more interactive inputs as needed
# Add download buttons for each panel
downloadButton("downloadPanel1", "Download Panel 1 (PDF)"),
downloadButton("downloadPanel2", "Download Panel 2 (PDF)")
),
mainPanel(
tabsetPanel(
# Panel 1 with four graphs
tabPanel(
"Panel 1",
plotOutput("plot1"),
plotOutput("plot2"),
plotOutput("plot3"),
plotOutput("plot4")
),
# Panel 2 with two graphs
tabPanel(
"Panel 2",
plotOutput("plot5"),
plotOutput("plot6")
)
)
)
)
)
# Define server
server <- function(input, output) {
# Create reactive plots based on user input
output$plot1 <- renderPlot({
ggplot(mtcars, aes(x = mpg)) + geom_histogram(binwidth = input$bins, fill = "blue", color = "black")
})
output$plot2 <- renderPlot({
# Create another plot based on user input or different data
# Example: boxplot
ggplot(mtcars, aes(x = factor(cyl), y = mpg)) + geom_boxplot(fill = "green", color = "black")
})
output$plot3 <- renderPlot({
# Create another plot based on user input or different data
# Example: scatterplot
ggplot(mtcars, aes(x = hp, y = mpg)) + geom_point(color = "red")
})
output$plot4 <- renderPlot({
# Create another plot based on user input or different data
# Example: density plot
ggplot(mtcars, aes(x = wt, fill = gear)) + geom_density(alpha = 0.5)
})
output$plot5 <- renderPlot({
# Create another plot based on user input or different data
# Example: bar plot
ggplot(mtcars, aes(x = gear)) + geom_bar(fill = "purple", color = "black")
})
output$plot6 <- renderPlot({
# Create another plot based on user input or different data
# Example: violin plot
ggplot(mtcars, aes(x = factor(gear), y = mpg, fill = factor(cyl))) + geom_violin()
})
# Create download handler for Panel 1
output$downloadPanel1 <- downloadHandler(
filename = function() {
paste("Panel1_", Sys.Date(), ".pdf", sep = "")
},
content = function(file) {
pdf(file, width = 8, height = 6)
print(output$plot1)
print(output$plot2)
print(output$plot3)
print(output$plot4)
dev.off()
}
)
# Create download handler for Panel 2
output$downloadPanel2 <- downloadHandler(
filename = function() {
paste("Panel2_", Sys.Date(), ".pdf", sep = "")
},
content = function(file) {
pdf(file, width = 8, height = 6)
print(output$plot5)
print(output$plot6)
dev.off()
}
)
}
# Run the application
shinyApp(ui, server)
